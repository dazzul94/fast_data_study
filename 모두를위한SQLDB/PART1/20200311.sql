/* ### LIKE연산자:
* - 어떠한 컬럼의 값이 특정 값과 유사한 패턴을 갖는 집합을 출력하는 연산자이다. */

/* 1. LIKE */
select
	first_name,
	last_name
from customer c
where first_name like 'Jen%';

/* 2. TRUE, FALSE를 리턴한다.
* _는 한개의 문자를 의미한다.*/
select
	'FOO' like 'FOO',
	'FOO' like 'F%',
	'FOO' like '_O_',
	'BAR' like 'B_',
	'BAR' like 'B%',
	'BAR' like 'B__';

/* 3. %사용 */
select
	first_name,
	last_name
from customer c
where first_name like '%er%';

/* 4. _와 % 사용*/
select
	first_name,
	last_name
from customer c
where first_name like '_her%';

/* 5. NOT LIKE */
select
	first_name,
	last_name
from customer c
where first_name not like 'Jen%';
-----------------------------------------------------------

/* ### IS NULL연산자:
* - 특정 컬럼 혹은 값이 널값인지 아닌지를 판단하는 연산자.
* - NULL이란? 아무것도 아닌 값. 널 값을 판단할때는 = null로 하면 안된다.
*/
create table contacts ( 
	id int generated by default as identity,
	first_name varchar(50) not null,
	last_name varchar(50) not null,
	email varchar(255) not null,
	phone varchar(15), primary key(id) ); -- 커밋할 필요없다. 실행한 순간 테이블 생성.
	
insert into contacts(
	first_name,
	last_name,
	email,
	phone) 
values
	('John', 'Doe', 'john.doe@xample.com', null),
	('Lily', 'Bush', 'lily.bush@xample.com', '408-234-2764');

commit;

select
	*
from contacts c;

/* 1. = null은 안먹는다.*/
select
	id,
	first_name,
	last_name,
	email,
	phone
from contacts
where phone = null;

/* 2. IS NULL */
select
	id,
	first_name,
	last_name,
	email,
	phone
from contacts
where phone is null;

/* 3. IS NOT NULL */
select id,
	first_name,
	last_name,
	email,
	phone
from contacts
where phone is not null;
/* NULL은 아무것도 아니라고 표시하는 값 */

-----------------------------------------------------------
/* ### 실습 문제1 */

/* 1. PAYMENT 테이블에서 단일 거래의 AMOUNT의 액수가 가장 많은 고객들의 CUSTOMER_ID를 추출하라.
* 단, CUSTOMER_ID의 값은 유일해야 한다. */
-- 내가 한거
select
	distinct customer_id
	from payment p2
	where amount = (
		select
			max(amount)
		from payment p3);
-- 선생님이 한거
-- 서브쿼리를 쓰면 ALIAS를 써주는게 좋다. 같은 컬럼이 존재할 때 가독성이 좋다.
select
	distinct a.customer_id
from payment a
where a.amount = ( -- 결과 집합이 1개라는 보장이 있기 때문에 =으로 써도 된다. 여러개라면 IN으로 조건 걸어야함.
	select
		k.amount
	from payment k
	order by k.amount desc limit 1);